// =====================================
// UNIT CONVERTER UTILITY
// =====================================

export interface UnitConversion {
  mm: number;
  cm: number;
  px: number;
  inches: number;
}

export class UnitConverter {
  // Constantes de conversión
  static readonly MM_TO_PX = 3.779; // 300 DPI conversion
  static readonly PX_TO_MM = 1 / UnitConverter.MM_TO_PX;
  static readonly MM_TO_CM = 0.1;
  static readonly CM_TO_MM = 10;
  static readonly INCHES_TO_MM = 25.4;
  static readonly MM_TO_INCHES = 1 / UnitConverter.INCHES_TO_MM;

  // Cache para optimizar rendimiento
  private static rulerMarksCache = new Map<string, Array<{ position: number; value: number; isMajor: boolean; label?: string }>>();
  private static cacheMaxSize = 50;

  /**
   * Limpia el cache de marcas de reglas
   */
  static clearRulerMarksCache(): void {
    UnitConverter.rulerMarksCache.clear();
  }

  /**
   * Genera una clave única para el cache
   */
  private static getCacheKey(lengthPx: number, unit: 'mm' | 'cm', zoom: number): string {
    // Redondear valores para optimizar cache hits
    const roundedLength = Math.round(lengthPx);
    const roundedZoom = Math.round(zoom * 100) / 100;
    return `${roundedLength}-${unit}-${roundedZoom}`;
  }

  /**
   * Convierte píxeles a milímetros
   */
  static pxToMm(px: number): number {
    return px * UnitConverter.PX_TO_MM;
  }

  /**
   * Convierte milímetros a píxeles
   */
  static mmToPx(mm: number): number {
    return mm * UnitConverter.MM_TO_PX;
  }

  /**
   * Convierte milímetros a centímetros
   */
  static mmToCm(mm: number): number {
    return mm * UnitConverter.MM_TO_CM;
  }

  /**
   * Convierte centímetros a milímetros
   */
  static cmToMm(cm: number): number {
    return cm * UnitConverter.CM_TO_MM;
  }

  /**
   * Convierte píxeles a centímetros
   */
  static pxToCm(px: number): number {
    return UnitConverter.mmToCm(UnitConverter.pxToMm(px));
  }

  /**
   * Convierte centímetros a píxeles
   */
  static cmToPx(cm: number): number {
    return UnitConverter.mmToPx(UnitConverter.cmToMm(cm));
  }

  /**
   * Convierte píxeles a pulgadas
   */
  static pxToInches(px: number): number {
    return UnitConverter.pxToMm(px) * UnitConverter.MM_TO_INCHES;
  }

  /**
   * Convierte pulgadas a píxeles
   */
  static inchesToPx(inches: number): number {
    return UnitConverter.mmToPx(inches * UnitConverter.INCHES_TO_MM);
  }

  /**
   * Obtiene todas las conversiones de una medida en píxeles
   */
  static getAllConversions(px: number): UnitConversion {
    return {
      px: Math.round(px * 100) / 100,
      mm: Math.round(UnitConverter.pxToMm(px) * 100) / 100,
      cm: Math.round(UnitConverter.pxToCm(px) * 100) / 100,
      inches: Math.round(UnitConverter.pxToInches(px) * 1000) / 1000,
    };
  }

  /**
   * Formatea un valor con su unidad
   */
  static formatValue(value: number, unit: 'px' | 'mm' | 'cm' | 'in'): string {
    switch (unit) {
      case 'px':
        return `${Math.round(value)}px`;
      case 'mm':
        return `${Math.round(value * 10) / 10}mm`;
      case 'cm':
        return `${Math.round(value * 100) / 100}cm`;
      case 'in':
        return `${Math.round(value * 1000) / 1000}"`;
      default:
        return `${value}`;
    }
  }

  /**
   * Calcula marcas de regla para una dimensión dada
   */
  static getRulerMarks(
    lengthPx: number, 
    unit: 'mm' | 'cm' = 'mm',
    zoom: number = 1
  ): Array<{ position: number; value: number; isMajor: boolean; label?: string }> {
    const cacheKey = UnitConverter.getCacheKey(lengthPx, unit, zoom);
    if (UnitConverter.rulerMarksCache.has(cacheKey)) {
      return UnitConverter.rulerMarksCache.get(cacheKey)!;
    }

    const marks: Array<{ position: number; value: number; isMajor: boolean; label?: string }> = [];
    
    const lengthInUnit = unit === 'mm' ? UnitConverter.pxToMm(lengthPx) : UnitConverter.pxToCm(lengthPx);
    
    // Determinar el intervalo basado en zoom y unidad - OPTIMIZADO
    let majorInterval: number;
    let minorInterval: number;
    
    // Algoritmo mejorado: calcular intervalos más consistentes
    if (unit === 'mm') {
      if (zoom >= 4) {
        majorInterval = 5; // cada 5mm
        minorInterval = 1;  // cada 1mm
      } else if (zoom >= 2.5) {
        majorInterval = 10; // cada 1cm
        minorInterval = 2;  // cada 2mm
      } else if (zoom >= 1.5) {
        majorInterval = 10; // cada 1cm
        minorInterval = 5;  // cada 5mm
      } else if (zoom >= 0.8) {
        majorInterval = 20; // cada 2cm
        minorInterval = 10; // cada 1cm
      } else if (zoom >= 0.4) {
        majorInterval = 50; // cada 5cm
        minorInterval = 10; // cada 1cm
      } else if (zoom >= 0.2) {
        majorInterval = 100; // cada 10cm
        minorInterval = 20;  // cada 2cm
      } else {
        majorInterval = 200; // cada 20cm
        minorInterval = 50;  // cada 5cm
      }
    } else { // cm
      if (zoom >= 4) {
        majorInterval = 0.5;   // cada 5mm
        minorInterval = 0.1;   // cada 1mm
      } else if (zoom >= 2.5) {
        majorInterval = 1;   // cada 1cm
        minorInterval = 0.2; // cada 2mm
      } else if (zoom >= 1.5) {
        majorInterval = 1;   // cada 1cm
        minorInterval = 0.5; // cada 5mm
      } else if (zoom >= 0.8) {
        majorInterval = 2;   // cada 2cm
        minorInterval = 1;   // cada 1cm
      } else if (zoom >= 0.4) {
        majorInterval = 5;   // cada 5cm
        minorInterval = 1;   // cada 1cm
      } else if (zoom >= 0.2) {
        majorInterval = 10;  // cada 10cm
        minorInterval = 2;   // cada 2cm
      } else {
        majorInterval = 20;  // cada 20cm
        minorInterval = 5;   // cada 5cm
      }
    }

    // Optimización: limitar número máximo de marcas
    const maxMarks = 200;
    const estimatedMinorMarks = Math.ceil(lengthInUnit / minorInterval);
    
    if (estimatedMinorMarks > maxMarks) {
      // Ajustar intervalos si hay demasiadas marcas
      const factor = Math.ceil(estimatedMinorMarks / maxMarks);
      minorInterval *= factor;
      majorInterval *= factor;
    }

    // Generar marcas menores de forma optimizada
    const minorMarkCount = Math.ceil(lengthInUnit / minorInterval);
    for (let i = 0; i <= minorMarkCount; i++) {
      const value = i * minorInterval;
      if (value > lengthInUnit) break;
      
      const positionPx = unit === 'mm' ? UnitConverter.mmToPx(value) : UnitConverter.cmToPx(value);
      
      marks.push({
        position: positionPx,
        value,
        isMajor: false
      });
    }

    // Generar marcas mayores con etiquetas de forma optimizada
    const majorMarkCount = Math.ceil(lengthInUnit / majorInterval);
    for (let i = 0; i <= majorMarkCount; i++) {
      const value = i * majorInterval;
      if (value > lengthInUnit) break;
      
      const positionPx = unit === 'mm' ? UnitConverter.mmToPx(value) : UnitConverter.cmToPx(value);
      
      marks.push({
        position: positionPx,
        value,
        isMajor: true,
        label: UnitConverter.formatValue(value, unit)
      });
    }

    const sortedMarks = marks.sort((a, b) => a.position - b.position);
    
    // Gestión del cache: limitar tamaño
    if (UnitConverter.rulerMarksCache.size >= UnitConverter.cacheMaxSize) {
      const firstKey = UnitConverter.rulerMarksCache.keys().next().value;
      if (firstKey) {
        UnitConverter.rulerMarksCache.delete(firstKey);
      }
    }
    
    UnitConverter.rulerMarksCache.set(cacheKey, sortedMarks);
    return sortedMarks;
  }
}